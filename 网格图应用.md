# 网格图应用



# DFS

## [矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)



![{27F6E05C-5283-431E-B1AE-B155CA4E8B8A}](./assets/{27F6E05C-5283-431E-B1AE-B155CA4E8B8A}-1733805287809-2.png)

注意元素是**递增的性质**，那么一个元素就只能往比它大的元素移动，这里要求统计最长路径长度，可以使用dfs加记忆化搜索找出从每个位置出发能得到的最长路径。

```python
class Solution:
    def longestIncreasingPath(self, g: List[List[int]]) -> int:
        if not g:return 0
        m,n=len(g),len(g[0])
        dirs=[(1,0),(0,1),(0,-1),(-1,0)]
        @cache
        def dfs(i,j):
            res=1
            for dx,dy in dirs:
                if 0<=(x:=dx+i)<m and 0<=(y:=dy+j)<n and g[x][y]>g[i][j]:
                    res=max(dfs(x,y)+1,res)
            return res 
        ans=0
        for i in range(m):
            for j in range(n):
                ans=max(ans,dfs(i,j))
        return ans 
```





# BFS

## [隔离病毒](https://leetcode.cn/problems/contain-virus/)

![{5AC2CAB5-4833-41E3-8659-B4654A810868}](./assets/{5AC2CAB5-4833-41E3-8659-B4654A810868}.png)

最初的想法记录每个连通块，让后一轮对所有的连通块做Bfs，但是这种做法无法处理连通块相连。

按照**天数**进行模拟，每一轮**重置vis矩阵**，**使用bfs找到连通块并往外扩展**，在bfs中记录连通块中有哪些点l1，以及有哪些点会被感染l2（这里不去重），在对所有的连通块做完bfs后，**找出能感染最多(威胁最大)的连通块（题目保证唯一）**，**把这个连通块中的点都设置为-1**，这样在之后就不能访问相当于隔离了，这一轮所建立的防火墙的数量等于l2的长度，因为防火墙是所有已感染区域到未感染区域的边界，如果一个区域会被感染,**那么感染几次及记录几次**，这个次数就是对于这个位置要建立的防火墙个数。**对于其他的连通块按照l2进行扩散**

```python
class Solution:
    def containVirus(self, g: List[List[int]]) -> int:
        m,n=len(g),len(g[0])
        ans=0
        def cal():
            vis=[[False]*n for _ in range(m)]
            tmp1=[]
            tmp2=[]
            mx=-1
            for i in range(m):
                for j in range(n):
                    if not vis[i][j] and g[i][j]==1:
                        def speard(i,j):
                            d=deque()
                            d.append((i,j))
                            vis[i][j]=True
                            l1=[]
                            l2=[]
                            while d:
                                i,j=d.popleft()
                                l1.append((i,j))
                                for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                                    if 0<=(x:=dx+i)<m and 0<=(y:=dy+j)<n and not vis[x][y] and g[x][y]!=-1:
                                        # 未被感染的区域，记录后即不再扩散了，能被感染就记录一次
                                        if not g[x][y]:l2.append((x,y))
                                        else:
                                            d.append((x,y))
                                            vis[x][y]=True
                            return l1,l2
                        l1,l2=speard(i,j)
                        # 注意要去重才能找出威胁最大的
                        if len(set(l2))>mx:
                            mx=len(set(l2))
                        tmp1.append(l1)
                        tmp2.append(l2)
            cnt=0
            for arr1,arr2 in zip(tmp1,tmp2):
                if len(set(arr2))==mx:
                    cnt=len(arr2)
                    # 隔离
                    for i,j in arr1:g[i][j]=-1
                else:
                    # 扩散
                    for i,j in arr2:g[i][j]=1
            return cnt

        

        while 1:
            cnt=cal()
            # 感染完了
            if not cnt:return ans 
            ans+=cnt
        

```

