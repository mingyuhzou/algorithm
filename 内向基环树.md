## 内向基环树

### [ 参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/)

<img src="E:/Git_/algorithm/img/image-20240223150503027.png" alt="image-20240223150503027" style="zoom:50%;" />

内向基环图，具有n个节点n条边的连通块，内向指的是连通块中的每个节点的出度为1，外向指的是入度为1，基环图中在基环外可以连接有多个树枝

每个员工只能坐在喜欢的人边上那么座次必须要满足是一个内向基环图

如果基环的大小大于等于3，那么圆桌上能做的人数就是基环的大小，一旦往这个环里向x->y插入其他的节点，一定会使得x不满足条件。

如果基环的大小为2，那么两个点的两边可以继续坐人也就是求出两个点的最长链，为此需要构造一个反图，此外在这个座次中可以继续坐入大小为2的基环。

<img src="E:/Git_/algorithm/img/image-20240223151401707.png" alt="image-20240223151401707" style="zoom:50%;" />

通过一次拓扑排序可以将树枝的入度变为0以此与基环分开，因为图谱排序中只能操作树枝，通过构建反图。

```python
class Solution:
    def maximumInvitations(self, favorite: List[int]) -> int:
        n=len(favorite)
	# 计算入度
        deg=[0]*n
        for f in favorite:
            deg[f]+=1
        q=deque([i for i,v in enumerate(deg) if not v])    
        r=defaultdict(list)
        # 将树枝与基环分开，基环是不会入队的
        while q:
            x=q.popleft()
            y=favorite[x]
            # 构建反图
            r[y].append(x)
            deg[y]-=1
            if not deg[y]:
                q.append(y)
         # 求出最长的链
        def dfs(x):
            if not r[x]:return 0
            return max(dfs(y)+1 for y in r[x])
        a=b=0
        # 遍历每一个点，找出基环
        for i,v in enumerate(deg):
            if not v:continue
            # 设置为0防止重复访问到
            deg[i]=0
            j=favorite[i]
            res=1
            # 一直顺着基环找
            while j!=i:
                deg[j]=0
                j=favorite[j]
                res+=1
            # 分类讨论 
            if res>2:
                a=max(a,res)
            elif res==2:
                # 基环长度为2的可以一直累加
                b+=dfs(i)+dfs(favorite[i])+res
        return max(a,b) 
```



### [图中的最长环](https://leetcode.cn/problems/longest-cycle-in-a-graph/)

<img src="E:/Git_/algorithm/img/image-20240430114009520.png" alt="image-20240430114009520" style="zoom:50%;" />





问题就是在找最大的基环数，把树枝通过拓扑排序与基环分开后直接去找基环的大小。

```python
class Solution:
    def longestCycle(self, edges: List[int]) -> int:
        n=len(edges)
        deg=[0]*n
        for f in edges:
            if f==-1:continue
            deg[f]+=1
        q=deque([i for i,v in enumerate(deg) if not v])
        # 基环是不会入队的
        while q:
            x=q.popleft()
            y=edges[x]
            if y==-1:continue
            deg[y]-=1
            if not deg[y]:
                q.append(y)
        ans=0
        for i,v in enumerate(deg):
            if not v:continue
            j=edges[i]
            res=1
            deg[i]=0
            while deg[j]:
                deg[j]=1
                j=edges[j]
                res+=1
            ans=max(ans,res)
        return ans if ans else -1
```



### **Reachability in Functional Graph**

![image-20240609164133716](E:/Git_/algorithm/assets/image-20240609164133716.png)

特意强调了每个点的出边只有一个，那么就是一个基环树。找两两可以相互到达的点首先看环，在环上的点能到达其他点的数目就是环的大小，作为分支的点可以到的点的数目就是就是他所连的点能到达的数目加一。

```python
from collections import deque,defaultdict
import sys
sys.setrecursionlimit(150000)
from functools import lru_cache

input=sys.stdin.readline

n=int(input())
nums=[int(x)-1 for x in input().split()]

e=[0]*n

for i,v in enumerate(nums):
    e[v]+=1

# 把环筛出来
p=[False]*n
d=deque([i for i,v in enumerate(e) if not v])
while d:
    curr=d.popleft()
    p[curr]=True
    k=nums[curr]
    if k==curr:continue
    e[k]-=1
    if not e[k]:d.append(k)

ans=[0]*n
# 计算环上每个点能连接的大小
for i in range(n):
    if not p[i]:
        cnt=0
        j=nums[i]
        while not p[j]:
            cnt+=1
            p[j]=True
            j=nums[j]
        for _ in range(cnt):
            ans[i]=cnt
            i=nums[i]
vis=set()

# 计算分支，使用递归注意要设置深度
@lru_cache(maxsize=None)
def dfs(i):
    if e[i]:return ans[i]
    return 1+dfs(nums[i])

for i,v in enumerate(e):
    if not v and i not in vis:
        ans[i]=dfs(i)
print(sum(ans))
```

















